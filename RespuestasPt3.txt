a) ¿Por qué no se dibuja la relación de agregación entre la clase `CollectionProducto` y `Producto`?

En el código `CollectionProducto` mantiene una lista estática `public static List<Producto> productos` que actúa como repositorio global. Como ese atributo es estático (pertenece a la clase y no a sus instancias) en los diagramas UML de instancia no se suele dibujar la típica agregación entre instancias del contenedor y las partes. Conceptualmente existe una relación de contención (Factura contiene Detalle / Collection contiene Productos), pero la implementación estática cambia cómo se modela visualmente y cómo se interpreta en un diagrama.

b) ¿Cuántos atributos tiene la clase `Factura`? ¿Cuáles son los nombres de esos atributos?

La clase `Factura` tiene 4 atributos:
- `fecha` (tipo `LocalDate`)
- `nroFactura` (tipo `long`)
- `cliente` (tipo `Cliente`)
- `detalles` (tipo `List<Detalle>`)

c) ¿Cómo se llama la relación que se establece entre `Factura` y `Detalle`?

La relación es una relación de contención: `Factura` contiene una colección de `Detalle`. Conceptualmente suele considerarse una composición (los detalles pertenecen a la factura y forman parte de ella). En el código esto está implementado como una lista dentro de `Factura`, que en UML puede representarse como una agregación/composición según el nivel de exigencia del modelo (si los `Detalle` sólo existen dentro de una `Factura` → composición).

d) ¿Cómo se llama la relación entre las clases `Factura` y `Cliente`?

Es una asociación (una referencia). `Factura` tiene una referencia a `Cliente` mediante el atributo `cliente`. El cliente existe independientemente de la factura, por lo que se describe como una asociación (no composición).

e) ¿Por qué los atributos de las clases Collections son públicos?

En este proyecto las colecciones se definieron como `public static` para usarlas como repositorios en memoria accesibles desde cualquier parte de la aplicación. Motivos prácticos:
- Permiten acceso global sencillo (no hace falta instanciar la clase Collection).
- Simulan un almacenamiento persistente en memoria para el TP (fácil de precargar y manipular).

Observación: exponer colecciones públicas es una mala práctica porque rompe el principio de encapsulación y puede provocar modificaciones no controladas. Es preferible declarar los atributos como `private` y ofrecer métodos controlados (add/remove/find) o exponer vistas inmutables.

f) Describa las características de todos los métodos de la clase `CollectionCliente`.

La clase `CollectionCliente` implementa un pequeño repositorio en memoria. Sus métodos principales son:

- `precargarClientes()`
	- `static`
	- Sin parámetros
	- Inicializa la lista con datos de ejemplo si la lista está vacía (evita duplicados)

- `agregarCliente(Cliente cliente)`
	- `static`
	- Recibe un `Cliente` y lo agrega a la lista
	- Usa `try/catch` para capturar errores y muestra un mensaje en caso de fallo

- `buscarCliente(long dni)`
	- `static`
	- Recibe un `dni` (long) y retorna el `Cliente` encontrado o `null` si no existe
	- Itera la lista y compara por `dni`; envuelve la operación en `try/catch` para seguridad

Todas las operaciones son estáticas y actúan sobre la lista compartida `clientes`.
